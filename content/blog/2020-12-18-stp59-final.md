+++
title="Loop Unrolling in the Networking Domain"
[extra]
bio = """
  Samwise Parkinson is a first-year graduate student of computer science at Cornell University, working on formal verification of network programming language implementations.
"""
[[extra.authors]]
name = "Samwise Parkinson"
+++

Loop unrolling is a common and well-understood optimization. The basic insight is that many loops do the same computation many times, each time jumping to a new block of code. By duplicating loop body code and performing basic transformations on induction variable computations, we should be able to do fewer computations and we need fewer jumps, which always tend to hurt performance.

However, loops in the domain of network programming languages have entirely different semantics. Typical hardware targets (e.g. routers) are usually quite different from traditional CPUs, usually requiring statically allocated, straight-line code. As a result, many languages in the networking domain are intended to be terminating, or at least not to be Turing Complete. Loops, then, usually ought to be not much more than syntactic sugar for essentially copy-pasting the same code some `n` times with a small change at each copy. For this reason, loop-unrolling is less an optimization than a fundamental feature of a language's static and dynamic semantics. It is also needed less for the sake of effecienty repeating the same comuptation thousands of times, and more for finding an acceptable version of the source program which can be loaded onto networking hardware.

This project explores this unique treatment of loop unrolling in the network programming language P4. P4 which is used to program network switches and routers, is of the most practical and widely used languages in the domain. Most of the language resembles basic C without `for` and `while` statements. Loops in P4 come in the form of the parser sublanguage, which resembles a finite state machine (FSM) and is used by a network device to extract meta-data from ingoing packets into useful data structures (TODO example).

Unfortunately, P4's only specification comes in the form of a ~200 page pdf documents consisting of vague English descriptions, pseudocode, and examples. For example, the document acknowledges that targets typically require straight-line code, yet it turns out that the parser sublanguage (the only part that has loops) is [Turing Complete](https://github.com/p4lang/p4-spec/issues/46). All the [spec](https://p4.org/p4-spec/docs/P4-16-v1.2.0.html) does to address this is make a vague suggestion that this be handled on a per-target basis:

```
Although parsers may contain loops, provided some header is extracted on each cycle, the packet itself provides a bound on the total execution of the parser. In other words, under these assumptions, the computational complexity of a P4 program is linear in the total size of all headers, and never depends on the size of the state accumulated while processing data (e.g., the number of flows, or the total number of packets processed).

... 

Architectures may impose (static or dynamic) constraints on the number of parser states that can be traversed for processing each packet. For example, a compiler for a specific target may reject parsers containing loops that cannot be unrolled at compilation time or that may contain cycles that do not advance the cursor.
```

Believe it or not, the above two blocks comprise the entirety of the P4 spec's treatment of this problem. This, in a turing complete language which targets hardware that is not turing complete. It is clear that this needs further study.

[Petr4]() is a long-term project which strives to build a formally verified end-to-end compiler for P4, along with [formal operational semantcs] for the surface syntax. As it exists now, it consists of a [front-end](https://github.com/cornell-netlab/petr4) with a type-checker and evaluator in OCaml, from which [formal semantics](https://popl21.sigplan.org/details/POPL-2021-research-papers/41/Petr4-Formal-Foundations-for-P4-Data-Planes) have been extracted on pencil-and-paper. 

This project's goal is to study the problem of loop-unrolling in P4 by proposing a more clearly-defined static semantics for parser loops and implementing them in conjunction with basic loop unrolling using the Petr4 ASTs. The implementation should not be concerned with optimization so much as correctness, termination, and static allocation. My current [implementation](https://github.com/cornell-netlab/petr4/pull/252) is in OCaml and runs about 500 loc. By comparison, the implementation of the reference compiler, [p4c](https://github.com/p4lang/p4c) runs about 350 loc and does not provide a tool for static analysis. The hope is that this implementation will soon be ported to Coq, where it can be the first of many transformations on P4 programs to be verified by Petr4 and related projects.

## Implementation

### Static Semantics of Parser Loops

The surface syntax of P4 parsers consists of local declarations followed by states. These states are composed of a highly restricted set of statements (variable assignments and method calls only) followed by a transition statement, indicating a jump to another state. Transitions may be conditional, branching to arbitrarily many different other states. The result is a system in which arbitrary irreducible control flow may arise.

However, the common case is to use a natural loop in the parser to populate a header stack, a data type in P4 consisting of an array and a point to an index in the array. Fortunately, extracting from the packet into a header stack has the side effect of incrementing the index pointer. What's more, the size of header stacks is a compile-time known constant used by the type system, and the dynamic semantics of incrementing the stack pointer past the stack size is clearly defined. Therefore, parser loops extracting into header stacks are guarantee to run a compile-time known constant number of iterations before terminating. More generally, parser loops that extract from the packet at all on each iteration are guaranteed to terminate due to the fact that the packet has a finite length.

With these considerations, I am able to provide a concrete proposal for a static analysis tool of parser loops. Accepted parsers should meet the following conditions:

1) They should have reducible control flow
2) Every distinct natural loop should include a block which both extracts from the packet and dominates all paths to the loop header

My implementation runs these checks, providing the user with option to fail when they are not satisfied or to emit a warning and produce unmodified code. Surprisingly, this was the most computationally heavy part of the implementation. While natural loops are easily identified about a backedge in the control flow, arbitrary loops require a full traversal of the control flow graph (CFG). I used [Tarjan's Strongly Connected Components Algorithm](https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm), which boasts linear runtime, to compute strongly-connected components of an arbitrary CFG. I then check that they all satisfied the criteria for forming a natural loop, that there exists a unique header node `h` which dominates all other nodes in the strongly-connected component and which is the only node with incoming edges from outside of the loop. Having identified the natural loops, I then traverse them to ensure that every path back to the header consumes the packet. Again, this ensures termination as packets are guaranteed to be finite.

### Loop Transformation

The next phase of my implementation transforms the CFG. I implement a basic form of loop unrolling which merely duplicates the loop body `n` times. I chose to skip the steps of identifying and collapsing induction variables at this time, since the domain is not so concerned with the efficiency of these loops (discussed above). I attempt to use some hueristics (below) to compute `n` statically, and failing this fall back to a default value for `n` provided by the user. The user also provides a flag indicating whether the unrolling should result in a control flow that still contains loops with the body duplicated, or if they prefer that the control flow raise an error after the `n` iterations. This will be useful as a user may be able to determine at compile time how large these loops need to be. Additionally, the transformation in future versions may be verifiable relative to an assumption that such an `n` exists.

Heuristics for computing `n` statically require further study, and indeed should never be able to acheive completeness due to decidability concerns. However, as I have mentioned, one common case involves header stacks. Loops which extract to header stacks every iteration can be unrolled to `n+1` copies of straight-line code, where `n` is the size of the stack, and the semantics ought to be identical (this clearly merits a Coq verification in the future). My current implementation is for Petr4's raw AST output by the parser, which is preferable because it provides a pretty printer back to P4 source code. However, switching to the typed AST, fully decorated with typing information by the type checker, will be possible once pretty printing is supported. This done, computing `n` becomes trivial, whereas it is unnecessarily difficult (and therefore unsupported) in my current version.

## Evaluation

I use three metrics for evaluation: correctness of the code transformation, and the soundness and completeness of the static analysis tools.

For correctness, I begin with a minimal collection of toy p4 programs which I developed for the sake of test-driven development. Residing in `petr4/unroll-test`, these are edge-case control flow programs which are primarily expected-fail for the static analysis. Conveniently, Petr4 already includes a robust test harness which runs the front-end on the entirety of p4c's benchmark suite. Combined with some custom test cases from the front-end development, this runs over 100 realistic p4 programs, each on several realistc packets, all in under a few seconds. In order to acquire reasonable evidence of the correctness of my transformation, I merely had to insert a call to my unroller in this test harness before type checking. After some work, my tool acheives the same correctness as the Petr4's evaluation on unmodified code. The only limitation of this approach is that it does not include any negative tests, so I am much more sure of the correctness of my code transformation tool than I am of my static analysis tool.

Soundness would require that every non-terminating P4 program be rejected by my static analysis. With a tool that rejects irreducible CFGs and loops that do not consume the packet, I can be reasonably comfortable with the soundness of my analysis. I group exceptions to soundness into two categories. The first consists of pending edge cases that are trivial upon switching to the typed AST. For example, I currently treat any call to `extract` as consuming the packet, whereas calling `extract` on an empty datatype does not actually consume the packet. Fixing this hole is difficult in an untyped AST but trivial in a typed one. The second category might be described as small semantic edge cases which would require a more computationally heavy analysis to resolve. The primary example of these is that I treat calls to `advance` (consume a certain number of bits in the packet without writing them anywhere) as consuming the packet without checking that the argument is non-zero. Doing so would likely require some even as involved as a dataflow analysis, and could be elided by porting my tool to slightly lower-level stages of the Petr4 pipeline where this is not a concern.

Completeness, as discussed, is unattainable in practice. For instance, less is known about analyzing and transforming irreducible control flow, a task that would be necessary in order to increase completeness. However, I do view my heuristics for statically computing the number of unrollings as a step forward in this direction.
