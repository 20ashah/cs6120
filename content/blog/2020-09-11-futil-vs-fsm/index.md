+++
title = "Cost of Abstraction in Compilers for Accelerator Generation"
extra.author = "Rachit Nigam"
extra.bio = """
  [Rachit Nigam](https://rachitnigam.com) is a second year PhD student interested in
  programming languages & computer architecture. In his free time, he
  [subtweets](https://twitter.com/notypes/status/1170037148290080771) his advisor and [annoys tenured professors](https://twitter.com/natefoster/status/1074401015565291520).
"""
+++

The blog post provides and overview of the [FuTIL][] compiler infrastructure
for designing accelerator generators and compares the designs generated by
it with a hand-crafted compiler generator.

The results are **TODO**.

### Generating Hardware Accelerators

Hardware acceleration in the form of specialized processors has become
increasingly common---from the graphics processing units (GPUs) that
accelerate everything from shader programs to linear algebra, to the tens
of new specialized AI chips that promise to run your favorite machine learning
models an order of magnitude faster.

Field programmable gate arrays (FPGAs) are a kind of reconfigurable
architecture that can be used to simulate hardware designs.
More recently, they have been become widely available on public clouds such
as AWS and Azure, accelerating many kinds of computations.
For an in-depth look into reconfigurable fabrics for accelerator design,
see this [blog post][reconf-future].

While incredibly flexible, FPGAs are a pain to program. The tools and languages
repurpose preexisting hardware design languages such as Verilog and VHDL.
While perfectly usable for precise hardware design, Verilog-like languages
require specification of every gate, wire, and clock cycle.
Building and iterating accelerators with them is a chore; imagine trying to
implement a matrix-multiply kernel by specifying every single wire (then
try imagining changing one design parameter requiring a pervasive rewrite).

Because of this verbose and tedious programming model, researchers and
practitioners have tried to design higher level programming models, either
by re-purposing legacy languages like C/C++ or building [entirely][spatial]
[new][aetherling] [languages][dahlia].

However, building such languages requires a lot of infrastructure---designing
the frontend, picking an architectural template, optimizing the generated
hardware, and generating code that can be run on an FPGA.
Instead of redesigning everything from scratch, the [FuTIL][] infrastructure hopes
to create a "LLVM for hardware design" by allowing frontends to target a small,
but expressive language, and automatically handling the "boring" optimization
and generation problems.

### Fused Temporal Intermediate Language (FuTIL)

FuTIL is an intermediate language and a compiler infrastructure for building
accelerator generators

[reconf-future]:
[futil]:
[spatial]:
[aetherling]:
[dahlia]:
