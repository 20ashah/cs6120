+++
title="Provably Correct Peephole Optimizations with Alive"
+++

## Contributions

This paper introduces Alive, a Domain-Specific Language designed for conveniently verifying LLVM optimizations. The Alive language provides a framework for encoding LLVM transformations of compiled code. The implementation uses a transformation encoding to generate preconditions and correctness conditions expressed in terms of predicates, which may then be automatically verified by an SMT solver. The result is a verified LLVM optimization in Alive, which also provides a tool for extracting the optimization into C++ code. As an additional feature, the language supports built-in predicates which are implemented by dataflow analysis.

The main difficulty with verifying LLVM opmtimizations is that the source code may have undefined behaviors. For this reason, much of the interesting design decision for Alive are related to handling undefined behavior. In principle, Alive is intended to check that optimizations are *refining*, that is, that the set of behaviors of the target code is included in the set of behaviors of the source.

After introducing Aive, the paper turns toward more technical concerns. In particular, it proves two versions of a soundness theorem for Alive's verification method--it first considers the language without memory and pointer concerns, then re-introduces pointer arithmetic. The theorem in essence states that if the Alive back-end accepts a given optimization, then the code transformation is semantics-refining.

## Alive's Impact

At the time of publication, Alive's authors manually translated 334 LLVM peephole optimizations (InstCombine) to Alive out of a possible 1028 instructions, meaning 694 were not processed for verification. Out of the translated optimizations, the authors found 8 bugs where the most uncommon bug was due to the introduction of undefined behavior. The authors state that most of the time Alive runs in a few seconds while for instructions with multiplication and division it "can take several hours or longer to verify the larger bit-widths" as most SMT solvers struggle with such inputs. The remaining optimizations could not be translated as they include instructions that were not supported by Alive at the time.

In addition to verifying existing optimizations, the authors also created a LLVM+Alive version of the LLVM compiler where the optimization verified by Alive were replaced by the C++ code generated by Alive. On average, code generated by LLVM+Alive was 3% slower than LLVM's -O3 (the most aggressive optimization option) despite covering a fraction of the optimization LLVM offers.

Interestingly, the authors also recorded the number of LLVM optimizations that were used when testing LLVM+Alive on the SPEC benchmark. Optimizations covered by Alive were used 87000 times and only a small number of optimizations were used. 159 of the 334 were used in some way and the top ten of those optimizations account for almost 70% of the total invocations. The figure given in the paper is shown below.

![fig9](alive-fig9.png)

The authors also state the following in the introduction.

> [...] we have prevented dozens of bugs from getting into LLVM by monitoring the various InstCombine patches as they were committed to the LLVM subversion repository. Several LLVM developers are currently using the Alive prototype to check their InstCombine transformations.
>

### Alive2 (Detour)

Following this work, Alive's authors have improved on Alive in multiple ways including [floating-point support](alive-fp), a precondition [inference](alive-infer) tool for optimization and the formalization of Alive, called [AliveInLean](alive-lean), in the [Lean](lean) theorem prover (this work assumes that "proof obligations are correctly discharged by an SMT solver"). Most recently, the authors of Alive have switched Alive to [maintenance mode](alive-git) and introduced a newer version of Alive, called [Alive2](alive2-git). A nice introduction to Alive2 can be found in a series of blog posts ([1](alive2-blog1), [2](alive2-blog2), [3](alive2-blog3)). Alive2 supports regular LLVM code in addition to the DSL of Alive along with bidirectional verification (the => of Alive can be replaced with <=>). So far, Alive2 has found 58 total [bugs](alive2-bugs) in LLVM & [Z3](z3).

### Contributions to LLVM (Detour)

Some of the authors of this paper (everyone except Santosh Nagarakatte) have pushed for the [removal of undef](remove-undef-llvm) from LLVM and introduce a new construct they call freeze. freeze was [added](freeze-twitter) to [LLVM](freeze-llvm) but undef was not removed.

The most interesting aspect for this work is Regher's blog post on why (undefined behavior is not always unsafe programming)[undef!=unsafe]. In LLVM, the [undef](undef-val) is used to indicate that "the program is well-defined no matter what value is used" which gives an optimizer the freedom to optimize the program. Regher argues that undefined behavior at the programmer visible abstractions level allows for more efficient programs and simpler compilers at the cost of program correctness. On the other hand, undef in LLVM "is an internal design choice" that need not be visible for the programmer to allow for better optimizations. If error-checking can be done at the higher-level and we can conclude that a program does not need such checks, then undef can be inserted into code at the LLVM level which then means these error checks can be factored out and more optimizations can be applied. 

In general, computer science education considers undefined behavior a harmful concept. However, we also contend with the fact that undefined behavior might be required for aggressive optimizations and speculative execution. Alive seems to take a third route as articulated in Regher's blog post and documented in the LLVM documentation: undefined behavior is ok as long as it "refines' ' the original (source) program in some way.

> Undefined behavior is the result of a design decision: the refusal to systematically trap program errors at one particular level of a system. The responsibility for avoiding these errors is delegated to a higher level of abstraction.
> ...
> The essence of undefined behavior is the freedom to avoid a forced coupling between error checks and unsafe operations.

## Analysis

This paper's task is no simple one--it endeavors to introduce a brand-new DSL. It must therefore motivate the need for a new language, develop the language design and implementation process, present meta-theoretic properties about the language semantics, and provide a compelling evaluation of the language's initial/potential impact. Indeed, the authors are mostly successful in each of these tasks.

The paper's strongest points are the expository method for the language features and meta-theoretic results. It tells a compelling and accessible story about the statement and proof of the soundness result, and motivates each distinct language feature persuasively. The only difficulty is with accessibilty in the presentation of the language. This section can be rather difficult to understand without a solid background in LLVM, which causes the DSL part of the paper to lose impact with broader audiences. Of course, it is not in the scope of the paper to provide such a background, and for this reason it is not a cricital flaw.

The evaluation section is underwhelming yet promising. While the numbers may appear disappointing at first glance, it does serve as a proof of concept that the Alive verification tool can effectively eliminate bugs in real programs. Of course, it is also the case that at the time of this paper's publication, only a small portion of LLVM optimizations had been encoded in the Alive framework. As cited above, this has improved significantly in later stages of the project. Also, it is important to note that the tool already had several users at the time of publication, which is rare for an academic project.

The paper's greatest shortcoming is with regard to motivation. Both the concept of verifying LLVM optimizations and the need for a new DSL are essentially taken for granted, and the paper moves right into the technical details. This is not a serious error in many cases since the target audience may be well-informed and familiar with these motivations already. Indeed, the need for verification seems to be in high demand considering the Alive users. However, the need for a new DSL was perhaps a small blunder considering that the project eventually moved away from a new language and focused on verifying tranformations directly from the source language. In general, there is a high threshold for needing to design a whole new programming language, and it seems that this threshold was not met in the case of this verification tool


[alive-fp]: https://link.springer.com/chapter/10.1007/978-3-662-53413-7_16
[alive-infer]: https://dl.acm.org/doi/abs/10.1145/3062341.3062372
[alive-practical]: https://dl-acm-org.proxy.library.cornell.edu/doi/abs/10.1145/3166064
[alive-lean]: https://link.springer.com/chapter/10.1007/978-3-030-25543-5_25
[lean]: https://leanprover.github.io
[alive-git]: https://github.com/nunoplopes/alive
[alive2-git]: https://github.com/AliveToolkit/alive2
[alive2-blog1]: https://blog.regehr.org/archives/1722
[alive2-blog2]: https://blog.regehr.org/archives/1737
[alive2-blog3]: https://blog.regehr.org/archives/1837
[alive2-bugs]: https://github.com/AliveToolkit/alive2/blob/master/BugList.md
[z3]: https://github.com/Z3Prover/z3
[remove-undef-llvm]: https://lists.llvm.org/pipermail/llvm-dev/2016-October/106182.html
[freeze-twitter]: https://twitter.com/johnregehr/status/1191765816422760448?lang=en
[freeze-llvm]: https://github.com/llvm/llvm-project/commit/58acbce3def63a207b8f5a69318a9966
[taming-undef-behav]: https://dl.acm.org/doi/abs/10.1145/3140587.3062343
[undef!=unsafe]: https://blog.regehr.org/archives/1467
[undef-val]: http://llvm.org/docs/LangRef.html#undefined-values
