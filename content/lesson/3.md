+++
title = "Local Analysis & Optimization"
draft = true
[extra]
due = "September 21"
[[extra.readings]]
name = "slides from Phil Gibbons at CMU"
url = "http://www.cs.cmu.edu/afs/cs/academic/class/15745-s19/www/lectures/L3-Local-Opts.pdf"
details = "for more details and context on LVN"
+++
## Gist

### Intro & Simple DCE Passes

Contrasting local vs. global vs. interprocedural analysis.

Then, our first optimizations!

* Definition of dead code elimination (DCE).
* Globally unused instructions.
  * Derive an algorithm for deleting them.
  * Iterating to convergence.
  * Then implement it.
* Locally killed instructions.
  * The limits of local reasoning: why can't we do this globally?
  * Derive an algorithm for removing them.
  * Then implement that too.
* Let's try our new optimization pass out on the Bril benchmarks.
  * First, combine all your implementations into one command somehow (including iterating to convergence). Try out your passâ€”something like this:

        $ bril2json < bench.bril | python3 tdce.py | bril2txt

  * Next, try using `wc` to check static code size differences:

        $ bril2json < bench.bril | wc -l
        $ bril2json < bench.bril | python3 tdce.py | wc -l

  * Then profiling to measure dynamic instruction count:

        $ bril2json < bench.bril | brili -p 5
        $ bril2json < bench.bril | python3 tdce.py | brili -p 5

### Local Value Numbering

* Local value numbering.
  * Consider the common thread between dead code elimination (DCE), copy propagation, and common subexpression elimination. In some compilers classes/textbooks, these are all individual optimizations.
  * Value numbering is a general framework for understanding & optimizing computations.
  * If you can deeply understand the mystical metaphysics of value numbering, you will have gotten most of what you need to get out of this part of 6120.
* Extending LVN.
  * LVN can subsume constant folding, copy propagation, and algebraic identities. You will need to extend it with language semantics.
  * Write complete pseudocode for the base LVN algorithm, and work out where the "extension points" need to be to capture those optimizations.


## Tasks

* Implement "trivial" dead code elimination, in which you delete instructions that are never used before they are reassigned. Remember to iterate to convergence.
* Implement local value numbering. Make sure it eliminates some common subexpressions. Try pairing it with trivial dead code elimination as a post-processing step.
* For bonus "points," extend your LVN implementation to optimize the trickier examples given in class.
